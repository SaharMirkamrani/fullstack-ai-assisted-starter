---
description: 
globs: 
alwaysApply: false
---
# Backend AI Coding Rules

## ğŸ¯ Core Principles

- **Security First**: Implement proper authentication, authorization, input validation
- **Type Safety**: Use TypeScript for all new code with strict mode
- **Performance**: Optimize database queries, implement caching, use async/await
- **Scalability**: Design for horizontal scaling, use microservices patterns
- **Observability**: Comprehensive logging, monitoring, error tracking

## ğŸ—ï¸ Architecture & Structure

### Project Structure
```
server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/    # Request handlers
â”‚   â”œâ”€â”€ services/      # Business logic
â”‚   â”œâ”€â”€ models/        # Data models
â”‚   â”œâ”€â”€ middleware/    # Express middleware
â”‚   â”œâ”€â”€ routes/        # API routes
â”‚   â”œâ”€â”€ utils/         # Utilities
â”‚   â”œâ”€â”€ types/         # TypeScript types
â”‚   â””â”€â”€ config/        # Configuration
â”œâ”€â”€ prisma/            # Database schema
â””â”€â”€ tests/             # Test files
```

### Code Patterns
```typescript
// Controller pattern
export class UserController {
  constructor(private userService: UserService) {}

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const userData = req.body;
      const user = await this.userService.createUser(userData);
      res.status(201).json({ success: true, data: user });
    } catch (error) {
      this.handleError(error, res);
    }
  }

  private handleError(error: Error, res: Response): void {
    logger.error('Controller error:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
}

// Service pattern
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(userData: CreateUserDto): Promise<User> {
    // Business logic implementation
    return await this.userRepository.create(userData);
  }
}
```

## ğŸ” Security Guidelines

### Authentication & Authorization
```typescript
// JWT Authentication middleware
export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ success: false, message: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET!, (err: any, user: any) => {
    if (err) return res.status(403).json({ success: false, message: 'Invalid token' });
    req.user = user;
    next();
  });
};

// Role-based authorization
export const authorizeRoles = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'Insufficient permissions' });
    }
    next();
  };
};
```

### Input Validation
```typescript
// Use Joi or Zod for validation
import Joi from 'joi';

const createUserSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required(),
  name: Joi.string().min(2).required()
});

export const validateCreateUser = (req: Request, res: Response, next: NextFunction) => {
  const { error } = createUserSchema.validate(req.body);
  if (error) {
    return res.status(400).json({ 
      success: false, 
      message: error.details[0].message 
    });
  }
  next();
};
```

### Security Middleware
```typescript
// Rate limiting
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: { success: false, message: 'Too many requests' }
});

// Security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));
```

## ğŸ—„ï¸ Database Guidelines

### Query Optimization
```typescript
// Use Prisma for type-safe database access
export class UserRepository {
  async findUserWithPosts(userId: string): Promise<User | null> {
    return await prisma.user.findUnique({
      where: { id: userId },
      include: {
        posts: {
          select: { id: true, title: true, createdAt: true }
        }
      }
    });
  }

  // Pagination for large datasets
  async findUsers(page: number = 1, limit: number = 10): Promise<User[]> {
    const skip = (page - 1) * limit;
    return await prisma.user.findMany({
      skip, take: limit, orderBy: { createdAt: 'desc' }
    });
  }
}
```

### Database Transactions
```typescript
// Use transactions for data consistency
export class OrderService {
  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    return await prisma.$transaction(async (tx) => {
      const order = await tx.order.create({ data: orderData });
      await tx.product.update({
        where: { id: orderData.productId },
        data: { stock: { decrement: orderData.quantity } }
      });
      return order;
    });
  }
}
```

## ğŸ“¡ API Design

### RESTful Patterns
```typescript
// Standard REST endpoints
router.get('/users', userController.getUsers);
router.get('/users/:id', userController.getUser);
router.post('/users', userController.createUser);
router.put('/users/:id', userController.updateUser);
router.delete('/users/:id', userController.deleteUser);
```

### Response Format
```typescript
// Consistent response structure
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: string[];
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Success response
res.status(200).json({
  success: true,
  data: result,
  message: 'Operation completed successfully'
});

// Error response
res.status(400).json({
  success: false,
  message: 'Validation failed',
  errors: ['Email is required']
});
```

## ğŸ§ª Testing

### Unit Testing
```typescript
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = createMockUserRepository();
    userService = new UserService(mockUserRepository);
  });

  describe('createUser', () => {
    it('should create a new user successfully', async () => {
      const userData = { email: 'test@example.com', password: 'password123' };
      const expectedUser = { id: '1', ...userData };

      mockUserRepository.createUser.mockResolvedValue(expectedUser);
      const result = await userService.createUser(userData);

      expect(result).toEqual(expectedUser);
      expect(mockUserRepository.createUser).toHaveBeenCalledWith(userData);
    });
  });
});
```

### Integration Testing
```typescript
describe('User API', () => {
  let app: Express;

  beforeAll(async () => {
    app = createApp();
  });

  describe('POST /users', () => {
    it('should create a new user', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User'
      };

      const response = await request(app)
        .post('/users')
        .send(userData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.email).toBe(userData.email);
    });
  });
});
```

## ğŸš€ Performance

### Caching Strategy
```typescript
// Redis caching
export class CacheService {
  constructor(private redis: Redis) {}

  async get<T>(key: string): Promise<T | null> {
    const data = await this.redis.get(key);
    return data ? JSON.parse(data) : null;
  }

  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    await this.redis.setex(key, ttl, JSON.stringify(value));
  }
}
```

### Performance Monitoring
```typescript
// Request timing middleware
export const requestTimer = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('Request completed', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration
    });
  });
  
  next();
};
```

## ğŸ“Š Logging & Monitoring

### Structured Logging
```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});
```

### Error Handling
```typescript
// Global error handler
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error('Unhandled error', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method
  });

  if (error instanceof ValidationError) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: error.details
    });
  }

  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
};
```

## ğŸ”§ Configuration

### Environment Management
```typescript
import dotenv from 'dotenv';
dotenv.config();

export const config = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  database: { url: process.env.DATABASE_URL! },
  jwt: {
    secret: process.env.JWT_SECRET!,
    expiresIn: process.env.JWT_EXPIRES_IN || '24h'
  },
  redis: { url: process.env.REDIS_URL || 'redis://localhost:6379' }
} as const;
```

## ğŸ¯ Code Quality

### Naming Conventions
- camelCase for variables and functions
- PascalCase for classes and interfaces
- UPPER_SNAKE_CASE for constants
- Descriptive, meaningful names

### Comments & Documentation
- Comment complex business logic
- Document API endpoints with JSDoc
- Explain "why" not "what"
- Keep comments up to date

## âš ï¸ Security Checklist

- [ ] Implement proper authentication (JWT, sessions)
- [ ] Use role-based authorization
- [ ] Validate all inputs (Joi/Zod)
- [ ] Sanitize data before database operations
- [ ] Use parameterized queries (no SQL injection)
- [ ] Implement rate limiting
- [ ] Use HTTPS in production
- [ ] Set security headers (Helmet.js)
- [ ] Handle errors without exposing sensitive data
- [ ] Use secure session management
- [ ] Regular dependency updates
- [ ] Security testing and audits
- [ ] Input validation on all endpoints
- [ ] Proper CORS configuration
- [ ] CSRF protection for state-changing operations
