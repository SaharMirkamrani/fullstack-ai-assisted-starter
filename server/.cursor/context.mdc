---
description:
globs:
alwaysApply: false
---
# Backend Application Context

## 🏗️ Architecture Overview

This is a modern Node.js-based backend application with the following characteristics:

### Technology Stack
- **Runtime**: Node.js 18+ with TypeScript
- **Framework**: Express.js or Fastify
- **Database**: PostgreSQL with Prisma ORM
- **Authentication**: JWT tokens
- **Validation**: Joi or Zod
- **Testing**: Jest with Supertest
- **Documentation**: OpenAPI/Swagger
- **Monitoring**: Winston for logging, Prometheus for metrics

### Project Structure
```
server/
├── src/
│   ├── controllers/        # Request handlers (MVC pattern)
│   │   ├── auth/          # Authentication controllers
│   │   ├── users/         # User management controllers
│   │   └── api/           # API controllers
│   ├── services/          # Business logic layer
│   │   ├── auth/          # Authentication services
│   │   ├── users/         # User management services
│   │   └── email/         # Email services
│   ├── models/            # Data models and schemas
│   │   ├── user.model.ts
│   │   └── index.ts
│   ├── middleware/        # Express middleware
│   │   ├── auth.middleware.ts
│   │   ├── validation.middleware.ts
│   │   ├── error.middleware.ts
│   │   └── rate-limit.middleware.ts
│   ├── routes/            # API route definitions
│   │   ├── auth.routes.ts
│   │   ├── user.routes.ts
│   │   └── index.ts
│   ├── utils/             # Utility functions
│   │   ├── logger.ts
│   │   ├── crypto.ts
│   │   └── validators.ts
│   ├── types/             # TypeScript type definitions
│   │   ├── express.d.ts
│   │   ├── api.types.ts
│   │   └── index.ts
│   ├── config/            # Configuration files
│   │   ├── database.ts
│   │   ├── redis.ts
│   │   └── index.ts
│   └── tests/             # Test files
│       ├── unit/
│       ├── integration/
│       └── e2e/
├── prisma/                # Database schema and migrations
│   ├── schema.prisma
│   └── migrations/
├── docs/                  # API documentation
│   ├── swagger.json
│   └── postman/
├── scripts/               # Build and deployment scripts
├── .env.example           # Environment variables template
└── package.json
```

## 🗄️ Database Architecture

### Prisma Schema
```prisma
// Example schema structure
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  posts     Post[]
  orders    Order[]
  
  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String
  published Boolean  @default(false)
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  author    User     @relation(fields: [authorId], references: [id])
  
  @@map("posts")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}
```

### Database Patterns
- **UUID/CUID**: Use for primary keys
- **Timestamps**: Include createdAt and updatedAt
- **Soft Deletes**: Use deletedAt for data retention
- **Indexing**: Strategic indexes for performance
- **Migrations**: Version-controlled schema changes

## 🔐 Security Architecture

### Authentication Flow
1. **Registration**: Email/password with validation
2. **Login**: JWT token generation
3. **Token Refresh**: Automatic token renewal
4. **Logout**: Token invalidation
5. **Password Reset**: Secure reset flow

### Authorization Levels
- **Public**: No authentication required
- **Authenticated**: Valid JWT token required
- **Role-based**: Specific roles required
- **Resource-based**: Ownership verification

### Security Headers
```typescript
// Security middleware configuration
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

## 📡 API Design Patterns

### RESTful Endpoints
```
GET    /api/users          # List users (with pagination)
GET    /api/users/:id      # Get specific user
POST   /api/users          # Create new user
PUT    /api/users/:id      # Update user
DELETE /api/users/:id      # Delete user

GET    /api/users/:id/posts    # Get user's posts
POST   /api/users/:id/posts    # Create post for user
```

### GraphQL Alternative
```graphql
type User {
  id: ID!
  email: String!
  name: String!
  posts: [Post!]!
  createdAt: DateTime!
}

type Query {
  users(first: Int, after: String): UserConnection!
  user(id: ID!): User
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
}
```

### Response Standards
```typescript
// Success Response
{
  "success": true,
  "data": { ... },
  "message": "Operation completed successfully",
  "timestamp": "2024-01-01T00:00:00.000Z"
}

// Error Response
{
  "success": false,
  "message": "Validation failed",
  "errors": ["Email is required", "Password must be at least 8 characters"],
  "timestamp": "2024-01-01T00:00:00.000Z"
}

// Paginated Response
{
  "success": true,
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "totalPages": 10,
    "hasNext": true,
    "hasPrev": false
  }
}
```

## 🚀 Performance Optimization

### Caching Strategy
- **Redis**: Session storage and API response caching
- **Database**: Query result caching
- **CDN**: Static asset delivery
- **Browser**: HTTP caching headers

### Database Optimization
- **Connection Pooling**: Manage database connections
- **Query Optimization**: Use indexes and efficient queries
- **Read Replicas**: Separate read/write operations
- **Database Sharding**: Horizontal scaling

### API Performance
- **Rate Limiting**: Prevent abuse
- **Compression**: Gzip responses
- **Pagination**: Limit response sizes
- **Lazy Loading**: Load data on demand

## 📊 Monitoring & Observability

### Logging Strategy
```typescript
// Structured logging with Winston
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api-service' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});
```

### Metrics Collection
- **Application Metrics**: Response times, error rates
- **Business Metrics**: User registrations, API usage
- **Infrastructure Metrics**: CPU, memory, disk usage
- **Custom Metrics**: Feature usage, conversion rates

### Health Checks
```typescript
// Health check endpoint
app.get('/health', async (req, res) => {
  const health = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version,
    checks: {
      database: await checkDatabase(),
      redis: await checkRedis(),
      external: await checkExternalServices()
    }
  };
  
  res.json(health);
});
```

## 🔄 Development Workflow

### Environment Configuration
```typescript
// Environment variables
export const config = {
  // Server
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  
  // Database
  database: {
    url: process.env.DATABASE_URL!,
    pool: {
      min: parseInt(process.env.DB_POOL_MIN || '2'),
      max: parseInt(process.env.DB_POOL_MAX || '10')
    }
  },
  
  // Authentication
  jwt: {
    secret: process.env.JWT_SECRET!,
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d'
  },
  
  // Redis
  redis: {
    url: process.env.REDIS_URL || 'redis://localhost:6379',
    ttl: parseInt(process.env.REDIS_TTL || '3600')
  },
  
  // Email
  email: {
    provider: process.env.EMAIL_PROVIDER || 'sendgrid',
    apiKey: process.env.EMAIL_API_KEY!,
    from: process.env.EMAIL_FROM || 'noreply@example.com'
  }
} as const;
```

### Testing Strategy
- **Unit Tests**: Individual functions and classes
- **Integration Tests**: API endpoints and database operations
- **E2E Tests**: Complete user workflows
- **Performance Tests**: Load testing and stress testing

### CI/CD Pipeline
1. **Code Quality**: Linting, formatting, type checking
2. **Testing**: Unit, integration, and E2E tests
3. **Security**: Vulnerability scanning
4. **Build**: Docker image creation
5. **Deploy**: Staging and production deployment

## 🎯 Best Practices

### Code Organization
- **Separation of Concerns**: Controllers, services, repositories
- **Dependency Injection**: Use interfaces and DI containers
- **Error Handling**: Centralized error management
- **Validation**: Input validation at multiple layers

### API Design
- **Consistent Naming**: RESTful resource naming
- **Versioning**: API versioning strategy
- **Documentation**: OpenAPI/Swagger documentation
- **Rate Limiting**: Prevent API abuse

### Security
- **Input Validation**: Validate all inputs
- **Authentication**: Secure token-based auth
- **Authorization**: Role and resource-based access control
- **Data Protection**: Encrypt sensitive data

### Performance
- **Caching**: Strategic caching at multiple levels
- **Database**: Optimize queries and connections
- **Monitoring**: Real-time performance monitoring
- **Scaling**: Horizontal and vertical scaling strategies
