---
description:
globs:
alwaysApply: false
---
# Frontend AI Coding Rules

## üéØ General Principles

- **Component-First**: Build reusable, composable components
- **Type Safety**: Use TypeScript for all new code
- **Performance**: Optimize for bundle size and runtime performance
- **Accessibility**: Follow WCAG guidelines and ARIA best practices
- **Responsive**: Design for mobile-first, then enhance for larger screens

## üèóÔ∏è Architecture Guidelines

### Component Structure
```typescript
// Preferred component structure
interface ComponentProps {
  // Props interface
}

export const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // Hooks at the top
  const [state, setState] = useState();
  
  // Event handlers
  const handleEvent = () => {
    // Implementation
  };
  
  // Render
  return (
    <div>
      {/* JSX */}
    </div>
  );
};
```

### File Organization
- **Components**: `/components/` - Reusable UI components
- **Pages**: `/pages/` - Route-level components
- **Hooks**: `/hooks/` - Custom React hooks
- **Utils**: `/utils/` - Utility functions
- **Types**: `/types/` - TypeScript type definitions
- **Services**: `/services/` - API calls and external integrations

## üé® Styling Guidelines

### CSS-in-JS (Styled Components/Emotion)
```typescript
// Preferred styling approach
const StyledComponent = styled.div`
  display: flex;
  align-items: center;
  gap: 1rem;
  
  @media (max-width: 768px) {
    flex-direction: column;
  }
`;
```

### CSS Classes
- Use BEM methodology or similar naming convention
- Keep classes semantic and descriptive
- Avoid deep nesting (max 3 levels)

## üîß State Management

### Local State
- Use `useState` for component-local state
- Use `useReducer` for complex state logic

### Global State
- Prefer React Context for simple global state
- Use Redux Toolkit for complex state management
- Consider Zustand for lightweight global state

## üì° API Integration

### API Calls
```typescript
// Preferred API call pattern
const useApiData = <T>(endpoint: string) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await api.get(endpoint);
        setData(response.data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [endpoint]);

  return { data, loading, error };
};
```

## üß™ Testing Guidelines

### Component Testing
- Test component rendering and user interactions
- Mock external dependencies
- Test error states and loading states
- Use React Testing Library for component tests

### Test Structure
```typescript
describe('Component', () => {
  it('should render correctly', () => {
    // Test implementation
  });

  it('should handle user interactions', () => {
    // Test implementation
  });

  it('should handle error states', () => {
    // Test implementation
  });
});
```

## üöÄ Performance Guidelines

### Code Splitting
- Use React.lazy() for route-based code splitting
- Implement dynamic imports for heavy components
- Consider bundle analysis tools

### Optimization
- Use React.memo() for expensive components
- Implement useMemo() and useCallback() appropriately
- Optimize images and assets
- Minimize re-renders

## üîí Security Guidelines

### Input Validation
- Validate all user inputs
- Sanitize data before rendering
- Use Content Security Policy headers

### Authentication
- Implement proper token management
- Use secure storage for sensitive data
- Handle authentication errors gracefully

## üì± Mobile Considerations

### Touch Interactions
- Ensure touch targets are at least 44px
- Implement proper touch feedback
- Test on actual devices

### Performance
- Optimize for slower networks
- Implement progressive loading
- Consider offline functionality

## üéØ Code Quality

### Naming Conventions
- Use PascalCase for components
- Use camelCase for variables and functions
- Use UPPER_SNAKE_CASE for constants
- Use descriptive, meaningful names

### Comments
- Comment complex business logic
- Document component props with JSDoc
- Explain "why" not "what" in comments

### Error Handling
- Implement proper error boundaries
- Provide meaningful error messages
- Log errors appropriately
- Graceful degradation for failures
